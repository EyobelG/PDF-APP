<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>BestPDFEditor — Live</title>

  <!-- Tailwind -->
  <script src="https://cdn.tailwindcss.com"></script>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@100..900&display=swap" rel="stylesheet">

  <!-- pdf.js and pdf-lib -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.16.105/pdf.min.js"></script>
  <script src="https://unpkg.com/pdf-lib/dist/pdf-lib.js"></script>

  <style>
    :root{--ui-bg:#f8fafc;--accent:#ffbe0a;--purple:#500082;--text:#0f172a}
    body { font-family: Inter, system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial; background: var(--ui-bg); color: var(--text); }
    .pattern-layer { position: fixed; inset:0; z-index:-1; background: linear-gradient(45deg, rgba(80,0,130,0.06) 25%, transparent 25%) 0 0/40px 40px, linear-gradient(-45deg, rgba(255,190,10,0.04) 25%, transparent 25%) 0 0/40px 40px; }
    /* centered canvas area */
    .viewer { display:flex; gap:1rem; height: calc(100vh - 72px); padding: 1rem; box-sizing:border-box; }
    .sidebar { width: 18rem; background: white; border-radius: 0.75rem; padding: 1rem; box-shadow: 0 6px 30px rgba(16,24,40,0.06); }
    .rightbar { width: 18rem; background: white; border-radius: 0.75rem; padding: 1rem; box-shadow: 0 6px 30px rgba(16,24,40,0.06); }
    .canvas-wrap { flex:1; display:flex; align-items:center; justify-content:center; overflow:auto; }
    .pdf-stage { position: relative; background: #e6eef8; padding: 1rem; border-radius: 0.75rem; display:inline-block; }
    canvas#pdf-canvas { display:block; border-radius: 6px; box-shadow: 0 10px 30px rgba(2,6,23,0.12); background:white; }
    /* overlay layer sits above canvas */
    #overlay-layer { position: absolute; left: 0; top: 0; pointer-events: none; }
    .overlay-item { position:absolute; pointer-events: auto; }
    .text-editor {
      min-width: 40px;
      max-width: 80vw;
      min-height: 24px;
      outline: none;
      border: 1px dashed rgba(16,24,40,0.12);
      background: rgba(255,255,255,0.85);
      padding: 4px 6px;
      border-radius: 4px;
      box-shadow: 0 2px 6px rgba(16,24,40,0.08);
      resize: none;
    }
    .tool-btn { display:flex; gap:.5rem; align-items:center; justify-content:center; padding:.5rem; border-radius:.5rem; cursor:pointer; user-select:none; }
    .tool-btn.active { background: var(--purple); color: white; }
    .statusbar { height: 44px; display:flex; align-items:center; gap:1rem; padding:0 1rem; background: white; border-top: 1px solid rgba(2,6,23,0.04); }
    .small { font-size: 0.85rem; color: #475569; }
    input[type=color] { width: 2.5rem; height:2.3rem; padding:0; border-radius: 6px; border: none; }
    /* hide file input */
    #pdfFile { display:none; }
  </style>
</head>
<body>
  <div class="pattern-layer"></div>

  <header class="flex items-center justify-between px-6 py-4 bg-white shadow-sm">
    <div class="flex items-center gap-4">
      <h1 class="text-2xl font-bold text-primary-purple" style="color:var(--purple)">BestPDFEditor</h1>
      <label for="pdfFile" class="px-3 py-1 border border-gray-200 rounded-md cursor-pointer small">Open PDF</label>
      <input id="pdfFile" type="file" accept="application/pdf" />
      <div id="file-name" class="small text-gray-500 ml-2">No file loaded</div>
    </div>

    <div class="flex items-center gap-4">
      <div class="small text-gray-600" id="page-display">—</div>
      <div class="small text-gray-600">Zoom:</div>
      <button id="zoom-out" class="px-2 py-1 border rounded small">−</button>
      <div id="zoom-level" class="px-2 small">100%</div>
      <button id="zoom-in" class="px-2 py-1 border rounded small">+</button>
      <button id="download-btn" class="px-4 py-2 bg-yellow-400 rounded font-semibold shadow">Save PDF</button>
    </div>
  </header>

  <main class="viewer">
    <!-- Left toolbar -->
    <aside class="sidebar">
      <div class="mb-4">
        <div class="font-semibold">Tools</div>
        <div class="mt-3 grid grid-cols-2 gap-2">
          <div id="tool-select" class="tool-btn border small">Select</div>
          <div id="tool-text" class="tool-btn border small">Text</div>
          <div id="tool-draw" class="tool-btn border small">Draw</div>
          <div id="tool-eraser" class="tool-btn border small">Eraser</div>
          <div id="clear-page" class="tool-btn border small col-span-2">Clear Page Overlays</div>
        </div>
      </div>

      <div class="mb-4">
        <div class="font-semibold">Appearance</div>
        <div class="mt-3 flex items-center gap-2">
          <input type="color" id="color-picker" value="#ffbe0a" title="Pick color" />
          <div class="small text-gray-600">Color</div>
        </div>
        <div class="mt-3">
          <label class="small text-gray-600">Font size</label>
          <input id="font-size" type="range" min="8" max="72" value="18" class="w-full" />
        </div>
        <div class="mt-3">
          <label class="small text-gray-600">Stroke width</label>
          <input id="stroke-width" type="range" min="1" max="20" value="2" class="w-full" />
        </div>
      </div>

      <div>
        <div class="font-semibold">Page Controls</div>
        <div class="mt-3 flex gap-2">
          <button id="prev-page" class="px-3 py-1 border rounded small">Prev</button>
          <button id="next-page" class="px-3 py-1 border rounded small">Next</button>
        </div>
      </div>
    </aside>

    <!-- Canvas center -->
    <section class="canvas-wrap">
      <div class="pdf-stage" id="pdf-stage">
        <canvas id="pdf-canvas"></canvas>
        <!-- overlay layer (positioned absolutely on top of canvas) -->
        <div id="overlay-layer"></div>
      </div>
    </section>

    <!-- Rightbar (info + download) -->
    <aside class="rightbar">
      <div class="font-semibold mb-2">Summary</div>
      <div class="small text-gray-600 mb-3">Edits are applied live on the canvas. Use "Save PDF" to generate the final PDF with all edits merged.</div>

      <div class="mt-4">
        <div class="font-semibold">Actions</div>
        <div class="mt-2 flex flex-col gap-2">
          <button id="download-btn-2" class="px-4 py-2 bg-yellow-400 rounded font-semibold">Save PDF</button>
          <button id="reset-all" class="px-4 py-2 border rounded">Reset All</button>
        </div>
      </div>

      <div class="mt-6">
        <div class="font-semibold">Tips</div>
        <ul class="list-disc ml-5 mt-2 small text-gray-600">
          <li>Text: select Text tool then click anywhere to type. Press Enter or click outside to commit.</li>
          <li>Draw: drag to draw. Use Eraser to remove last stroke on a page.</li>
          <li>Zoom with the buttons, overlays scale responsively.</li>
        </ul>
      </div>
    </aside>
  </main>

  <footer class="statusbar">
    <div id="status" class="small">Ready — Open a PDF to begin.</div>
  </footer>

<script>
/* -----------------------------
   Globals & state
   ----------------------------- */
pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.16.105/pdf.worker.min.js';

let pdfJsDoc = null;           // pdf.js document (for rendering background)
let originalPdfBytes = null;   // original file bytes (used when generating final PDF)
let currentPage = 1;
let pageCount = 0;

let scale = 1.0;               // zoom
const MIN_SCALE = 0.25, MAX_SCALE = 4;

const overlays = []; // overlays[pageIndex] = { texts: [...], strokes: [...] }

const state = {
  tool: 'select', // select | text | draw | eraser
  color: '#ffbe0a',
  fontSize: 18,
  strokeWidth: 2,
  drawing: false,
  currentStroke: null
};

/* DOM */
const fileInput = document.getElementById('pdfFile');
const fileNameEl = document.getElementById('file-name');
const pdfCanvas = document.getElementById('pdf-canvas');
const canvasCtx = pdfCanvas.getContext('2d');
const overlayLayer = document.getElementById('overlay-layer');
const pdfStage = document.getElementById('pdf-stage');
const statusEl = document.getElementById('status');
const pageDisplayEl = document.getElementById('page-display');
const zoomLevelEl = document.getElementById('zoom-level');

/* toolbar elements */
const toolSelectBtn = document.getElementById('tool-select');
const toolTextBtn   = document.getElementById('tool-text');
const toolDrawBtn   = document.getElementById('tool-draw');
const toolEraserBtn = document.getElementById('tool-eraser');
const clearPageBtn  = document.getElementById('clear-page');

const colorPicker = document.getElementById('color-picker');
const fontSizeInput = document.getElementById('font-size');
const strokeWidthInput = document.getElementById('stroke-width');

const prevPageBtn = document.getElementById('prev-page');
const nextPageBtn = document.getElementById('next-page');

const zoomInBtn  = document.getElementById('zoom-in');
const zoomOutBtn = document.getElementById('zoom-out');

const downloadButtons = [document.getElementById('download-btn'), document.getElementById('download-btn-2')];
const resetAllBtn = document.getElementById('reset-all');

/* -----------------------------
   Helpers
   ----------------------------- */
function showStatus(msg, timeout=2200) {
  statusEl.textContent = msg;
  if (timeout) {
    clearTimeout(showStatus._t);
    showStatus._t = setTimeout(()=> {
      statusEl.textContent = 'Ready';
    }, timeout);
  }
}

function setTool(toolName) {
  state.tool = toolName;
  // active class toggle
  [toolSelectBtn, toolTextBtn, toolDrawBtn, toolEraserBtn].forEach(btn => btn.classList.remove('active'));
  if (toolName === 'select') toolSelectBtn.classList.add('active');
  if (toolName === 'text') toolTextBtn.classList.add('active');
  if (toolName === 'draw') toolDrawBtn.classList.add('active');
  if (toolName === 'eraser') toolEraserBtn.classList.add('active');

  // pointer behavior: enable pointer events on overlay for text/select; for draw, overlay should not capture pointer
  if (toolName === 'text' || toolName === 'select') {
    overlayLayer.style.pointerEvents = 'auto';
    pdfCanvas.style.cursor = 'text';
  } else if (toolName === 'draw') {
    overlayLayer.style.pointerEvents = 'none';
    pdfCanvas.style.cursor = 'crosshair';
  } else if (toolName === 'eraser') {
    overlayLayer.style.pointerEvents = 'auto';
    pdfCanvas.style.cursor = 'not-allowed';
  } else {
    overlayLayer.style.pointerEvents = 'auto';
    pdfCanvas.style.cursor = 'default';
  }

  showStatus(`Tool: ${toolName}`);
}

/* Convert a client (mouse) position to PDF coordinates based on current scale and canvas size.
   PDF coordinates assume origin (0,0) at bottom-left. We store overlays in PDF coordinates so scaling
   and zoom don't disrupt saved positions.
*/
function clientToPdfCoords(clientX, clientY) {
  const rect = pdfCanvas.getBoundingClientRect();
  const xOnCanvas = clientX - rect.left;
  const yOnCanvas = clientY - rect.top;
  // account for the CSS transform scale; our canvas drawing is actual pixel width*scale, but we set canvas.width = viewport.width * scale,
  // and we render using scale=scale on context; to simplify: we will treat canvas intrinsic width/height as the rendered dimensions (we set them accordingly).
  // So pdfX = xOnCanvas / scaleToPdf where scaleToPdf = canvas.width / pdfPageWidth
  const pageWidthPx = pdfCanvas.width;  // actual pixel width used for rendering
  const pageHeightPx = pdfCanvas.height;
  // We will store PDF coords normalized to PDF units (points): map proportionally to pdf page size (we saved pageSizesInPoints when rendering)
  const pdfPage = pageSizesInPoints[currentPage - 1];
  if (!pdfPage) return { x: xOnCanvas, y: yOnCanvas };

  const pdfX = (xOnCanvas / pageWidthPx) * pdfPage.width;
  // invert Y
  const pdfY = pdfPage.height - (yOnCanvas / pageHeightPx) * pdfPage.height;
  return { x: pdfX, y: pdfY };
}

/* Convert PDF coordinates (points) to overlay pixel coordinates (left, top) relative to canvas box,
   given the current canvas pixel dimensions.
*/
function pdfToOverlayCoords(pdfX, pdfY) {
  const pageWidthPx = pdfCanvas.width;
  const pageHeightPx = pdfCanvas.height;
  const pdfPage = pageSizesInPoints[currentPage - 1];
  if (!pdfPage) return { left: pdfX, top: pdfY };

  const left = (pdfX / pdfPage.width) * pageWidthPx;
  const top = ( (pdfPage.height - pdfY) / pdfPage.height ) * pageHeightPx;
  return { left, top };
}

function clamp(v, a, b) { return Math.max(a, Math.min(b, v)); }

/* -----------------------------
   Overlay management
   overlays[pageIndex] = { texts: [ {x,y,size,color,text,id} ... ], strokes: [ {points: [{x,y}], color, width, id} ... ] }
   ----------------------------- */
function ensureOverlayFor(pageIdx) {
  if (!overlays[pageIdx]) overlays[pageIdx] = { texts: [], strokes: [] };
  return overlays[pageIdx];
}

let idCounter = 1;
function genId(prefix='id') { return `${prefix}_${Date.now()}_${idCounter++}`; }

/* renderOverlayLayer: draws DOM items for currentPage's overlays (text boxes and strokes) */
function renderOverlayLayer() {
  // clear layer
  overlayLayer.innerHTML = '';
  const pageIdx = currentPage - 1;
  const ov = overlays[pageIdx];
  if (!ov) return;

  // draw strokes as an <svg> appended to overlay layer so they scale nicely with canvas
  if (ov.strokes && ov.strokes.length) {
    // create svg with same pixel dimensions as canvas
    const svgNS = 'http://www.w3.org/2000/svg';
    const svg = document.createElementNS(svgNS, 'svg');
    svg.setAttribute('width', pdfCanvas.width);
    svg.setAttribute('height', pdfCanvas.height);
    svg.style.position = 'absolute';
    svg.style.left = 0;
    svg.style.top = 0;
    svg.style.pointerEvents = 'none';
    ov.strokes.forEach(stroke => {
      if (!stroke.points || stroke.points.length < 2) return;
      const path = document.createElementNS(svgNS, 'path');
      const d = stroke.points.map((pt, i) => {
        // convert pdf coords to overlay coords
        const p = pdfToOverlayCoords(pt.x, pt.y);
        return (i === 0 ? `M ${p.left} ${p.top}` : `L ${p.left} ${p.top}`);
      }).join(' ');
      path.setAttribute('d', d);
      path.setAttribute('stroke', stroke.color || '#000');
      path.setAttribute('stroke-width', stroke.width || 2);
      path.setAttribute('fill', 'none');
      path.setAttribute('stroke-linecap', 'round');
      path.setAttribute('stroke-linejoin', 'round');
      svg.appendChild(path);
    });
    overlayLayer.appendChild(svg);
  }

  // create divs for texts
  if (ov.texts && ov.texts.length) {
    ov.texts.forEach(t => {
      const coords = pdfToOverlayCoords(t.x, t.y);
      const div = document.createElement('div');
      div.className = 'overlay-item';
      div.style.left = coords.left + 'px';
      div.style.top = coords.top + 'px';
      div.style.transform = 'translate(0,0)';
      // contenteditable-like appearance for committed text (not editable unless selected)
      const span = document.createElement('div');
      span.style.fontSize = (t.size * (pdfCanvas.width / pageSizesInPoints[currentPage - 1].width)) + 'px';
      span.style.color = t.color;
      span.style.fontWeight = '600';
      span.textContent = t.text;
      div.appendChild(span);
      // allow select -> if user double-clicks while in 'text' tool, open editor
      div.addEventListener('dblclick', (e) => {
        if (state.tool === 'text') openInlineTextEditor(div, t);
      });
      // right-click to delete when eraser tool active
      div.addEventListener('click', (e) => {
        if (state.tool === 'eraser') {
          // remove this text from overlays
          const idx = overlays[currentPage - 1].texts.findIndex(tt => tt.id === t.id);
          if (idx >= 0) overlays[currentPage - 1].texts.splice(idx,1);
          renderOverlayLayer();
        }
      });
      overlayLayer.appendChild(div);
    });
  }
}

/* Open an inline editable textarea on overlayLayer to edit/commit text */
function openInlineTextEditor(containerDiv, textObj, preferredLeftTop) {
  // Create editable element
  const editor = document.createElement('div');
  editor.contentEditable = 'true';
  editor.className = 'text-editor';
  editor.style.position = 'absolute';
  editor.style.left = (preferredLeftTop ? preferredLeftTop.left : containerDiv.style.left) + 'px';
  editor.style.top  = (preferredLeftTop ? preferredLeftTop.top  : containerDiv.style.top ) + 'px';
  editor.style.minWidth = '60px';
  editor.style.maxWidth = '60vw';
  editor.style.fontSize = (textObj.size * (pdfCanvas.width / pageSizesInPoints[currentPage - 1].width)) + 'px';
  editor.style.color = textObj.color;
  editor.innerText = textObj.text || '';
  editor.style.pointerEvents = 'auto';
  overlayLayer.appendChild(editor);
  editor.focus();

  function commit() {
    const newText = editor.innerText.trim();
    if (newText.length === 0) {
      // delete
      const idx = overlays[currentPage - 1].texts.findIndex(tt => tt.id === textObj.id);
      if (idx >= 0) overlays[currentPage - 1].texts.splice(idx,1);
    } else {
      textObj.text = newText;
    }
    overlayLayer.removeChild(editor);
    renderOverlayLayer();
  }

  editor.addEventListener('keydown', (ev) => {
    if (ev.key === 'Enter') {
      ev.preventDefault();
      commit();
    } else if (ev.key === 'Escape') {
      overlayLayer.removeChild(editor);
      renderOverlayLayer();
    }
  });

  editor.addEventListener('blur', commit);
}

/* Create new inline editor when user clicks in text mode */
function handleCanvasTextCreate(clientX, clientY) {
  // compute PDF coords
  const pdfCoords = clientToPdfCoords(clientX, clientY);
  const pageIdx = currentPage - 1;
  ensureOverlayFor(pageIdx);
  const id = genId('txt');
  const newText = { id, x: pdfCoords.x, y: pdfCoords.y, size: parseInt(state.fontSize,10), color: state.color, text: '' };
  overlays[pageIdx].texts.push(newText);

  // create editor positioned visually
  const overlayCoords = pdfToOverlayCoords(newText.x, newText.y);
  // create container div (in DOM) and open editor
  openInlineTextEditor(document.createElement('div'), newText, overlayCoords);
  renderOverlayLayer(); // will show committed items; editor is appended separately
}

/* Start a stroke when in draw mode */
function startStroke(clientX, clientY) {
  state.drawing = true;
  const pdfCoords = clientToPdfCoords(clientX, clientY);
  const stroke = { id: genId('stroke'), color: state.color, width: parseFloat(state.strokeWidth), points: [{x: pdfCoords.x, y: pdfCoords.y}] };
  ensureOverlayFor(currentPage - 1);
  overlays[currentPage - 1].strokes.push(stroke);
  state.currentStroke = stroke;
  renderOverlayLayer();
}

/* Continue stroke as mouse moves */
function continueStroke(clientX, clientY) {
  if (!state.drawing || !state.currentStroke) return;
  const pdfCoords = clientToPdfCoords(clientX, clientY);
  state.currentStroke.points.push({x: pdfCoords.x, y: pdfCoords.y});
  // For performance, we re-render overlay quickly
  renderOverlayLayer();
}

/* End stroke */
function endStroke() {
  state.drawing = false;
  state.currentStroke = null;
}

/* Eraser: remove nearest stroke or text within threshold */
function handleEraser(clientX, clientY) {
  const pdfCoords = clientToPdfCoords(clientX, clientY);
  const pageOv = overlays[currentPage - 1];
  if (!pageOv) return;

  // find nearest stroke point within tolerance (in PDF units)
  const TOLERANCE_PX = 8 * (pageSizesInPoints[currentPage - 1].width / pdfCanvas.width); // convert px to pdf units
  // remove stroke if any point near click
  for (let i = pageOv.strokes.length - 1; i >= 0; --i) {
    const stroke = pageOv.strokes[i];
    for (const pt of stroke.points) {
      const dx = pt.x - pdfCoords.x;
      const dy = pt.y - pdfCoords.y;
      if (Math.sqrt(dx*dx + dy*dy) < TOLERANCE_PX) {
        pageOv.strokes.splice(i, 1);
        renderOverlayLayer();
        return;
      }
    }
  }
  // also check text boxes: if click inside bounding box, remove text
  for (let i = pageOv.texts.length -1; i >= 0; --i) {
    const t = pageOv.texts[i];
    const BOX_W = Math.max(40, t.size * 4);
    const BOX_H = Math.max(16, t.size * 1.4);
    if (Math.abs(t.x - pdfCoords.x) < (BOX_W * (pageSizesInPoints[currentPage -1].width / pdfCanvas.width)) &&
        Math.abs(t.y - pdfCoords.y) < (BOX_H * (pageSizesInPoints[currentPage -1].height / pdfCanvas.height))) {
      pageOv.texts.splice(i,1);
      renderOverlayLayer();
      return;
    }
  }
}

/* Clear overlays for current page */
function clearCurrentPageOverlays() {
  overlays[currentPage - 1] = { texts: [], strokes: [] };
  renderOverlayLayer();
  showStatus('Cleared overlays for page ' + currentPage);
}

/* Reset all */
function resetAll() {
  for (let i = 0; i < overlays.length; ++i) overlays[i] = {texts:[], strokes:[]};
  renderOverlayLayer();
  showStatus('Reset all overlays');
}

/* -----------------------------
   PDF rendering (pdf.js)
   We'll store pageSizesInPoints (width/height in PDF points) to convert coordinates
   ----------------------------- */
const pageSizesInPoints = []; // index by page-1

async function loadPdfBytes(arrayBuffer, name) {
  originalPdfBytes = arrayBuffer.slice(0); // keep a copy
  pdfJsDoc = await pdfjsLib.getDocument({ data: arrayBuffer }).promise;
  pageCount = pdfJsDoc.numPages;
  fileNameEl.textContent = name || 'Loaded PDF';
  overlays.length = pageCount; // initialize slots
  for (let i=0;i<pageCount;i++) overlays[i] = { texts: [], strokes: []};
  await renderPage(1);
}

async function renderPage(pageNum) {
  if (!pdfJsDoc) return;
  currentPage = clamp(pageNum, 1, pageCount);
  const page = await pdfJsDoc.getPage(currentPage);
  // get viewport at scale = 1 for PDF point sizes; then set canvas pixel size according to desired scale.
  const unscaledViewport = page.getViewport({ scale: 1 });
  pageSizesInPoints[currentPage - 1] = { width: unscaledViewport.width, height: unscaledViewport.height };

  // Determine display scale so the page fits comfortably into pdf-stage container width if needed
  // We'll render using scaleValue = baseScale * devicePixelRatio * zoom scale
  const container = pdfStage;
  const maxWidth = Math.max(400, container.clientWidth - 32);
  let baseScale = 1;
  if (unscaledViewport.width > maxWidth) {
    baseScale = maxWidth / unscaledViewport.width;
  }
  const deviceRatio = window.devicePixelRatio || 1;
  const renderScale = baseScale * scale;

  const viewport = page.getViewport({ scale: renderScale });

  // set canvas pixel size
  pdfCanvas.width = Math.round(viewport.width * deviceRatio);
  pdfCanvas.height = Math.round(viewport.height * deviceRatio);
  pdfCanvas.style.width = Math.round(viewport.width) + 'px';
  pdfCanvas.style.height = Math.round(viewport.height) + 'px';
  // adjust overlay layer size and position
  overlayLayer.style.width = pdfCanvas.style.width;
  overlayLayer.style.height = pdfCanvas.style.height;
  overlayLayer.style.left = pdfCanvas.offsetLeft + 'px';
  overlayLayer.style.top = pdfCanvas.offsetTop + 'px';
  overlayLayer.style.pointerEvents = 'auto';
  overlayLayer.style.transform = 'translate(0,0)';

  // scale context for device pixel ratio
  canvasCtx.setTransform(deviceRatio, 0, 0, deviceRatio, 0, 0);
  canvasCtx.clearRect(0,0, pdfCanvas.width, pdfCanvas.height);

  const renderContext = {
    canvasContext: canvasCtx,
    viewport: viewport
  };

  await page.render(renderContext).promise;

  pageDisplayEl.textContent = `Page ${currentPage} / ${pageCount}`;
  zoomLevelEl.textContent = `${Math.round(scale * 100)}%`;

  // Ensure overlays are rendered for this page
  renderOverlayLayer();
}

/* -----------------------------
   Event wiring
   ----------------------------- */

// file input
fileInput.addEventListener('change', async (e) => {
  const f = e.target.files && e.target.files[0];
  if (!f) return;
  const ab = await f.arrayBuffer();
  await loadPdfBytes(ab, f.name);
  showStatus('Loaded PDF: ' + f.name);
});

// drag and drop onto stage
pdfStage.addEventListener('dragover', (ev) => { ev.preventDefault(); });
pdfStage.addEventListener('drop', async (ev) => {
  ev.preventDefault();
  const f = ev.dataTransfer.files && ev.dataTransfer.files[0];
  if (f && f.type === 'application/pdf') {
    const ab = await f.arrayBuffer();
    await loadPdfBytes(ab, f.name);
    showStatus('Loaded PDF: ' + f.name);
  } else {
    showStatus('Please drop a PDF file.');
  }
});

// tool buttons
toolSelectBtn.addEventListener('click', () => setTool('select'));
toolTextBtn.addEventListener('click', () => setTool('text'));
toolDrawBtn.addEventListener('click', () => setTool('draw'));
toolEraserBtn.addEventListener('click', () => setTool('eraser'));
clearPageBtn.addEventListener('click', clearCurrentPageOverlays);

// appearance
colorPicker.addEventListener('input', (e) => { state.color = e.target.value; showStatus('Color: ' + state.color); });
fontSizeInput.addEventListener('input', (e) => { state.fontSize = parseInt(e.target.value,10); showStatus('Font size: ' + state.fontSize); });
strokeWidthInput.addEventListener('input', (e) => { state.strokeWidth = parseInt(e.target.value,10); showStatus('Stroke width: ' + state.strokeWidth); });

// page navigation
prevPageBtn.addEventListener('click', () => { if (currentPage > 1) renderPage(currentPage - 1); });
nextPageBtn.addEventListener('click', () => { if (currentPage < pageCount) renderPage(currentPage + 1); });

// zoom
zoomInBtn.addEventListener('click', () => {
  scale = clamp(scale * 1.2, MIN_SCALE, MAX_SCALE);
  renderPage(currentPage);
});
zoomOutBtn.addEventListener('click', () => {
  scale = clamp(scale / 1.2, MIN_SCALE, MAX_SCALE);
  renderPage(currentPage);
});

// canvas interactions for drawing and text creation
function getCanvasClientPos(e) {
  // support touch events
  if (e.touches && e.touches[0]) {
    return { x: e.touches[0].clientX, y: e.touches[0].clientY };
  } else {
    return { x: e.clientX, y: e.clientY };
  }
}

pdfCanvas.addEventListener('mousedown', (e) => {
  const { x, y } = getCanvasClientPos(e);
  if (state.tool === 'draw') {
    startStroke(x, y);
    e.preventDefault();
  } else if (state.tool === 'text') {
    handleCanvasTextCreate(x, y);
    e.preventDefault();
  } else if (state.tool === 'eraser') {
    handleEraser(x, y);
  }
});
window.addEventListener('mousemove', (e) => {
  const { x, y } = getCanvasClientPos(e);
  if (state.drawing) continueStroke(x, y);
});
window.addEventListener('mouseup', (e) => {
  if (state.drawing) endStroke();
});

// touch support
pdfCanvas.addEventListener('touchstart', (e) => {
  const { x, y } = getCanvasClientPos(e);
  if (state.tool === 'draw') startStroke(x,y);
  else if (state.tool === 'text') handleCanvasTextCreate(x,y);
  e.preventDefault();
}, {passive:false});
pdfCanvas.addEventListener('touchmove', (e) => {
  const { x, y } = getCanvasClientPos(e);
  if (state.drawing) continueStroke(x,y);
  e.preventDefault();
}, {passive:false});
pdfCanvas.addEventListener('touchend', (e) => { if (state.drawing) endStroke(); }, {passive:false});

// Eraser: also allow clicking overlay items to delete when in eraser mode
overlayLayer.addEventListener('click', (e) => {
  if (state.tool === 'eraser') {
    // convert click pos
    const rect = pdfCanvas.getBoundingClientRect();
    const clientX = e.clientX;
    const clientY = e.clientY;
    handleEraser(clientX, clientY);
  }
});

// double-click on overlay -> if select tool, allow editing
overlayLayer.addEventListener('dblclick', (e) => {
  if (state.tool === 'text') {
    // find nearest text overlay and open editor (handled by each text item)
  }
});

// reset all button
resetAllBtn.addEventListener('click', () => {
  if (confirm('Reset all overlays? This cannot be undone in this session.')) {
    resetAll();
  }
});

/* -----------------------------
   Save (compile overlays onto a new PDF and download)
   Approach:
    - Load originalPdfBytes into a new PDFDocument (pdf-lib)
    - For each page: embed font, draw texts and strokes translating PDF coordinates to page-space (pdf-lib uses points)
    - Save and download
   ----------------------------- */
async function downloadEditedPdf() {
  if (!originalPdfBytes) { showStatus('No PDF loaded'); return; }
  showStatus('Compiling edited PDF — please wait (this may take a few seconds)...', 8000);

  try {
    const outDoc = await PDFLib.PDFDocument.load(originalPdfBytes);
    const helvetica = await outDoc.embedFont(PDFLib.StandardFonts.Helvetica);
    for (let p = 0; p < outDoc.getPageCount(); ++p) {
      const page = outDoc.getPage(p);
      const ov = overlays[p];
      const pageSize = { width: page.getWidth(), height: page.getHeight() };

      // draw texts
      if (ov && ov.texts) {
        for (const t of ov.texts) {
          // t.x, t.y are already in PDF points coordinates (we stored them that way)
          // pdf-lib drawText expects bottom-left origin (same), so just draw
          page.drawText(t.text || '', {
            x: t.x,
            y: t.y - (t.size * 0.2), // small baseline adjustment
            size: t.size,
            font: helvetica,
            color: PDFLib.rgb(parseInt(t.color.slice(1,3),16)/255, parseInt(t.color.slice(3,5),16)/255, parseInt(t.color.slice(5,7),16)/255),
            maxWidth: pageSize.width - t.x - 10
          });
        }
      }

      // draw strokes (render as many small line segments)
      if (ov && ov.strokes) {
        for (const s of ov.strokes) {
          if (!s.points || s.points.length < 2) continue;
          // draw each segment
          for (let i = 0; i < s.points.length - 1; ++i) {
            const a = s.points[i];
            const b = s.points[i+1];
            page.drawLine({
              start: { x: a.x, y: a.y },
              end:   { x: b.x, y: b.y },
              thickness: s.width,
              color: PDFLib.rgb(
                parseInt(s.color.slice(1,3),16)/255,
                parseInt(s.color.slice(3,5),16)/255,
                parseInt(s.color.slice(5,7),16)/255
              ),
              opacity: 1
            });
          }
        }
      }
    }

    const pdfBytes = await outDoc.save();
    const blob = new Blob([pdfBytes], { type: 'application/pdf' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    const baseName = (fileNameEl.textContent || 'document').replace(/\.\w+$/, '');
    a.download = baseName + '_edited.pdf';
    document.body.appendChild(a);
    a.click();
    a.remove();
    setTimeout(()=>URL.revokeObjectURL(url), 1500);
    showStatus('Download started', 3000);
  } catch (err) {
    console.error('Save error', err);
    showStatus('Error creating PDF — check console', 4000);
  }
}

/* Connect download buttons */
downloadButtons.forEach(btn => btn.addEventListener('click', downloadEditedPdf));

/* initial UI */
setTool('select');
showStatus('Ready — Open a PDF to begin.');

/* convenience: allow keyboard shortcuts */
window.addEventListener('keydown', (e) => {
  if (e.key === 't') setTool('text');
  if (e.key === 'd') setTool('draw');
  if (e.key === 's') setTool('select');
  if (e.key === 'e') setTool('eraser');
  if (e.key === 'z' && (e.ctrlKey || e.metaKey)) { e.preventDefault(); downloadEditedPdf(); }
});
</script>
</body>
</html>
